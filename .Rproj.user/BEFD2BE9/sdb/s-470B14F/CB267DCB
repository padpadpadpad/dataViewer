{
    "collab_server" : "",
    "contents" : "#' an interactive addin to help visualise data and identifiy outliers\n#'\n#' an interactive addin to help visualise data and identify outliers\n#'\n#' @param data the data frame that contains your raw data\n#' @param predictions the data frame that contains your predictions if desired\n#' @param id_col the column that splits your data frame by\n#' @param x the x variable\n#' @param y the y variable\n#' @param col an optional variable if different colours are desired for each plot\n#' @param group an optional variable for grouping model predictions when there are multiple prediction lines on a single plot\n#' @param lm_fit whether or not you want a linear model fit to be superimposed over the data. Defaults to FALSE\n#' @return a dataframe of the rows that are to be deleted\n#' @description opens a pane from which you can select each set of data and select points to be dropped. The undo button gets rid of the last selection. Press \"DONE\" to get a dataframe of the selected outliers.\n#' @examples\n#' # load in data\n#'\n#' data(\"Chlorella_TRC\")\n#' Chlorella_TRC_test <- Chlorella_TRC[Chlorella_TRC$curve_id %in% c(1:10),]\n#'\n#' # run nlsLoop()\n#'\n#' fits <- nlsLoop(ln.rate ~ schoolfield.high(ln.c, Ea, Eh, Th, temp = K, Tc = 20),\n#'                 data = Chlorella_TRC_test,\n#'                 tries = 500,\n#'                 id_col = 'curve_id',\n#'                 param_bds = c(-10, 10, 0.1, 2, 0.5, 5, 285, 330),\n#'                 lower = c(ln.c=-10, Ea=0, Eh=0, Th=0))\n#'\n#' \\dontrun{\n#' outliers <- dataViewer(data = Chlorella_TRC_test, predictions = fits$predictions,\n#' id_col = 'curve_id', x = 'K', y = 'ln.rate')\n#' }\n#'\n#' @export\n\ndataViewer <- function(data, predictions = NULL, id_col = NULL, x, y, col = NULL, group = NULL, lm_fit = FALSE){\n\n    # delete NAs from dataset\n    data <- data[!is.na(data[,y]),]\n    data <- data[!is.na(data[,x]),]\n\n    # colnames\n    cols <- colnames(data)\n\n    # one id column\n    if(is.null(id_col)){\n      id_col <-  'id_col'\n      data$id_col <- 'ALL THE DATA'}\n\n    # create all id_col\n    id <- unique(as.character(data[,id_col]))\n\n    # if missing col\n    if(is.null(col)){\n      data$col <- 'black'}\n    if(is.null(group)){\n      group = id_col}\n\n    # define the UI for the gadget\n    ui <- miniUI::miniPage(\n      # set title\n      miniUI::gadgetTitleBar(\"dataViewer\"),\n      # set up content panel\n      miniUI::miniContentPanel(\n                  shiny::selectInput(\"data\", \"Choose curve:\", choices = id),\n                  shiny::plotOutput(\"plot1\",\n                           click = \"plot1_click\",\n                           brush = shiny::brushOpts(id = 'plot1_brush',\n                                                    resetOnNew = TRUE))),\n      miniUI::miniButtonBlock(\n        shiny::actionButton(\"go_to_previous\", \"Previous\"),\n        shiny::actionButton(\"undo_last_point\", \"Undo\"),\n        shiny::actionButton(\"go_to_next\", \"Next\")\n      )\n    )\n\n    server <- function(input, output, session){\n      # For storing which rows have been excluded\n      vals <- shiny::reactiveValues(\n        deleted_rows = data[FALSE,],\n        number_of_points = NULL\n      )\n\n      # Define plot1\n      output$plot1 <- shiny::renderPlot({\n        # subset for keep rows\n        dat <- data[data[,id_col] == input$data,]\n        keep    <- get_unclicked(dat, vals$deleted_rows)\n        exclude <- get_clicked(dat, vals$deleted_rows)\n\n        ggplot2::update_geom_defaults(\"smooth\", list(colour = 'red', fill = 'red'))\n        ggplot2::update_geom_defaults(\"line\", list(colour = 'red', linetype = 2))\n\n        # no predictions\n        if(is.null(predictions)){\n          if(lm_fit == TRUE){\n\n\n\n            # plot 1\n            ggplot2::ggplot() +\n              ggplot2::geom_point(ggplot2::aes_string(x = x, y = y, col = col), size = 3, keep) +\n              ggplot2::geom_point(ggplot2::aes_string(x = x, y = y, col = col), shape = 21, size = 3, exclude, alpha = 0.75) +\n              ggplot2::theme_bw(base_size = 18, base_family = 'Helvetica') +\n              ggplot2::ggtitle(input$data) +\n              ggplot2::stat_smooth(ggplot2::aes_string(x = x, y = y, col = col, fill = col), method = 'lm', se = T, keep)\n          } else{\n            ggplot2::ggplot() +\n              ggplot2::geom_point(ggplot2::aes_string(x = x, y = y, col = col), size = 3, keep) +\n              ggplot2::geom_point(ggplot2::aes_string(x = x, y = y, col = col), shape = 21, size = 3, exclude, alpha = 0.75) +\n              ggplot2::theme_bw(base_size = 18, base_family = 'Helvetica') +\n              ggplot2::ggtitle(input$data)\n            }\n          } else {\n          # with predictions\n          preds <- predictions[predictions[,id_col] == input$data,]\n          # plot 1\n          ggplot2::ggplot() +\n            ggplot2::geom_line(ggplot2::aes_string(x = x, y = y, col = col, group = group), linetype = 2, size = 1.5, preds) +\n            ggplot2::geom_point(ggplot2::aes_string(x = x, y = y, col = col), size = 3, keep) +\n            ggplot2::geom_point(ggplot2::aes_string(x = x, y = y, col = col), shape = 21, size = 3, exclude, alpha = 0.75) +\n            ggplot2::theme_bw(base_size = 18, base_family = 'Helvetica') +\n            ggplot2::ggtitle(input$data)\n            }\n\n    })\n\n      # Make points that are clicked turn grey\n      shiny::observeEvent(input$plot1_click,{\n        dat <- data[data[,id_col] == input$data,]\n        vals$number_of_points <- c(vals$number_of_points, 1)\n        vals$deleted_rows <- rbind(vals$deleted_rows, shiny::nearPoints(dat, input$plot1_click, allRows = FALSE))\n      })\n\n      shiny::observeEvent(input$plot1_brush,{\n        dat <- data[data[,id_col] == input$data,]\n        vals$number_of_points <- c(vals$number_of_points, nrow(shiny::brushedPoints(dat, input$plot1_brush, allRows = FALSE)))\n        vals$deleted_rows <- rbind(vals$deleted_rows, shiny::brushedPoints(dat, input$plot1_brush, allRows = FALSE))\n      })\n\n      # Undo last click\n      shiny::observeEvent(input$undo_last_point,{\n        last_row <- tail(vals$number_of_points, 1)\n        vals$number_of_points <- vals$number_of_points[-length(vals$number_of_points)]\n\n        vals$deleted_rows <- head(vals$deleted_rows, nrow(vals$deleted_rows) - last_row)\n\n      })\n\n      # Move to next id\n      shiny::observeEvent(input$go_to_next, {\n        current_id <- input$data\n        next_id <- id[match(current_id, id) + 1]\n        shiny::updateSelectInput(session, 'data', choices = id, selected = next_id)\n        })\n\n      # Move to previous id\n      shiny::observeEvent(input$go_to_previous, {\n        current_id <- input$data\n        next_id <- id[match(current_id, id) - 1]\n        shiny::updateSelectInput(session, 'data', choices = id, selected = next_id)\n      })\n\n      # When the Done button is clicked, return a value\n      shiny::observeEvent(input$done, {\n        deleted_rows <- vals$deleted_rows\n        deleted_rows <- deleted_rows[,colnames(deleted_rows) %in% cols]\n        # Return the kept points ###\n        shiny::stopApp(\n          deleted_rows\n        )\n      })\n\n      }\n    # Run the app in the dialog viewer\n    shiny::runGadget(ui, server, viewer = shiny::dialogViewer('dataViewer', width = 700, height = 1200))\n  }\n\n",
    "created" : 1475932596923.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1492623457",
    "id" : "CB267DCB",
    "lastKnownWriteTime" : 1475933186,
    "last_content_update" : 1475933186717,
    "path" : "~/Desktop/R/dataViewer/R/dataViewer.R",
    "project_path" : "R/dataViewer.R",
    "properties" : {
        "chunk_rendered_width" : "627"
    },
    "relative_order" : 1,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}